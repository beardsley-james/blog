---
layout: post
title: Implementing Mythotopia Game Options
category: mythotopia
tags: [mythotopia, javascript, games]
---

## The Sample Game Object

[I built a sample game object for Mythopia][1]. It works pretty well for what's going on now. The fun part is that it isn't like a pre-built raw-programmed object, it's generated by a controller object that takes an option object and outputs a hopefully playable game state. This is basically what I need to start working with it, so it's pretty satisfying.

I decided to enter the data for the map spaces and cards into a Google Docs chart, then I saves it as comma-separated values and put it through a CSV to JSON converter. I used [convertcsv.com][2] because it let me use "/" separated values to set up nested objects, which was important since I decided to use an array of objects to represent connections between different spaces. There was probably a more efficient way to communicate that information but since I'm working with data instead of a graphical interface I can't imagine what it would be.

~~~json
"iracund": {
	"name": "Iracund",
	"resource": "food",
	"strength": 2,
	"connection": [
		{"to": "palmain"},
		{"to": "diclesium",	"type": "mountains"},
		{"to": "fadge"},
		{"to": "quean"},
		{"to": "blore"}
	]
}
~~~

So things are clipping along.

## App Structure

At this point I'm thinking the client-side program is going to handle a lot of the rule parsing. I know I wasn't originally going to do it that way but I think it might be better for my purposes. If the client-side program made the player pick appropriate cards, presented available options, that sort of thing, it might work better, but it would have to be real interactive with the server side to work out. But my thought is that the object sent back to the server should be something like this:

~~~json
{
	"action": "invade",
	"province": "iracund",
	"player": "James",
	"cardsUsed": {
		"iracund", "armyStart", "ship"
	}
}
~~~

And theoretically that should be enough for the server-side programming to apply the action, remove the cards from the player's hand, apply any applicable reserve characteristics to the action, etc. etc. Theoretically. I made two actions so far, ~placeArmies~ and ~removeArmies~ but they need some error-checking mechanisms built in to make sure the player doesn't end up with more army counters than he started with. ~placeArmies~ should, again theoretically, be all that's needed to handle both the "Invade a Province" action and the "Place Armies" action described in the rulebook but I have to think through possible repercussions of combining those two actions. There'll still be plenty of state-parsing before these action can be applied, of course, but I think it will be best to have some really grainy brute-force functions sitting at the core of this thing to change the actual game state.

I think the next step is to write all these game state functions. Right now my node server can (but does not) generate a new game with the game controller, applies a ~placeArmies~ function to one of the spaces, and displays on port 3000 the text version of the space's object, with the army counters listed. I feel pretty good about that.

Also to do is to make some CSS and View files so I can show the whole gamestate in a prettier way, that would be nice.

[1]: https://raw.githubusercontent.com/beardsley-james/mythotopia/master/scratchpad/sampleGame.js
[2]: http://www.convertcsv.com/csv-to-json.htm